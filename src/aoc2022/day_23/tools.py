# coding=utf-8
"""Tools used for solving the Day 23: Unstable Diffusion puzzle."""

# Standard library imports:
from collections import Counter
import itertools


Position = tuple[int, int]


class Elf:
    """Seedling-planting Elf looking for a good place for sowing a new star plant."""
    __slots__ = ["x", "y", "planned_position"]

    def __init__(self, x: int, y: int):
        self.x, self.y = x, y
        self.planned_position = self.position

    def __eq__(self, other: "Elf") -> bool:
        return self.x == other.x and self.y == other.y

    def __hash__(self) -> int:
        return hash((self.x, self.y))

    def __repr__(self) -> str:
        if self.needs_to_move:
            return f"{self.position} â†’ {self.planned_position}"
        return f"{self.position}"

    def plan(self, grove: "ElfGrove"):
        """Plan a new position for moving by evaluating the surroundings of this Elf."""
        possible_tiles = grove.get_available_tiles(elf=self)
        self.planned_position = self.position
        if len(possible_tiles) == 8:
            return  # This Elf is alone, it doesn't need to move.
        for target_direction in grove.check_order:
            tiles_in_dir = [d for d in possible_tiles.keys() if target_direction in d]
            if len(tiles_in_dir) == 3:
                self.planned_position = possible_tiles[target_direction]
                break

    def move(self, planned_count: dict[Position, int]):
        """Move to the planned position, if no other Elf planned to move there."""
        if planned_count[self.planned_position] == 1:
            self.x, self.y = self.planned_position
        self.planned_position = None

    @property
    def needs_to_move(self) -> bool:
        """Check if this Elf has planned to move to a different tile."""
        return self.position != self.planned_position

    @property
    def position(self) -> Position:
        """Current coordinates of this Elf."""
        return self.x, self.y


class ElfGrove:
    """Soon-to-be-covered-by-ash field where the star trees grow."""
    def __init__(self, elves: list[Elf]):
        self._rounds = 0
        self.elves = [*elves]
        self.check_order = ["N", "S", "W", "E"]
        self._make_plans()

    def evolve(self, rounds: int):
        """Make the Elves in the grove propose and execute movements during n rounds."""
        for _ in range(rounds):
            self._execute_plans()
            self._rotate_check_order()
            self._make_plans()
            self._rounds += 1

    def evolve_while_needed(self):
        """Keep planning and moving Elves until no Elf needs to move."""
        while any(elf.needs_to_move for elf in self.elves):
            self.evolve(rounds=1)

    def _make_plans(self):
        """Make each Elf in the grove propose its next movement."""
        self._positions = {elf.position for elf in self.elves}
        [elf.plan(grove=self) for elf in self.elves]

    def _execute_plans(self):
        """Make each Elf in the grove move to its planned new position (if possible)."""
        planned_tile_map = Counter(elf.planned_position for elf in self.elves)
        [elf.move(planned_count=planned_tile_map) for elf in self.elves]

    def get_available_tiles(self, elf: Elf) -> dict[str, Position]:
        """Find empty tiles adjacent to an Elf, and map them to their octa-direction."""
        directions = ["SW", "W", "NW", "S", "O", "N", "SE", "E", "NE"]
        movements = itertools.product([-1, 0, 1], repeat=2)
        positions = sorted([(elf.x + dx, elf.y + dy) for dx, dy in movements])
        return {d: p for d, p in zip(directions, positions) if p not in self._positions}

    def _rotate_check_order(self):
        """Move the first direction to consider to the end of the direction queue."""
        self.check_order = self.check_order[1:] + [self.check_order[0]]

    @property
    def completed_rounds(self) -> int:
        """Number of plan+movement rounds done so far."""
        return self._rounds

    @property
    def empty_tiles(self) -> int:
        """Count free tiles in the smallest rectangle containing all elves."""
        xs, ys = zip(*[elf.position for elf in self.elves])
        min_x, max_x = min(xs), max(xs)
        min_y, max_y = min(ys), max(ys)
        area_size = (max_x - min_x + 1) * (max_y - min_y + 1)
        return area_size - len(self.elves)

    @classmethod
    def from_scan(cls, scan_lines: list[str]) -> "ElfGrove":
        """Create a new ElfGrove from the row strings generated by your scanner."""
        scan_lines = scan_lines[::-1]
        xys = [(x, y) for x in range(len(scan_lines[0])) for y in range(len(scan_lines))]
        elves = [Elf(x=x, y=y) if scan_lines[y][x] == "#" else None for x, y, in xys]
        return cls(elves=list(filter(None, elves)))
